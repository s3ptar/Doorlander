/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : MPR08x1.c
**     Project     : Doorlander
**     Processor   : MCF51JM128VLH
**     Component   : MPR08x
**     Version     : Component 01.205, Driver 01.00, CPU db: 3.00.063
**     Compiler    : CodeWarrior ColdFireV1 C Compiler
**     Date/Time   : 2018-07-15, 09:31, # CodeGen: 16
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         SetSensitivity       - byte MPR08x1_SetSensitivity(byte sensitivity);
**         SetSounder           - byte MPR08x1_SetSounder(bool enable, byte clickPeriod, byte frequency);
**         GetSensorInformation - byte MPR08x1_GetSensorInformation(byte *buf, byte bufSize);
**         ProcessTouch         - void MPR08x1_ProcessTouch(void);
**
**     (c) Copyright Erich Styger, 2008
**     http      : www.hslu.ch
**     mail      : erich.styger@hslu.ch
** ###################################################################*/
/*!
** @file MPR08x1.c
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup MPR08x1_module MPR08x1 module documentation
**  @{
*/         

/* MODULE MPR08x1. */

#include "Events.h"
#include "MPR08x1.h"

#define TOGGLE_ATTN()   {Attn1_SetVal();WAIT1_Waitms(20);Attn1_ClrVal();WAIT1_Waitms(20);Attn1_SetVal();} /* ATTN pin toggle */
#define CONFIGURATION_REGISTER_SETTINGS    (((1-1)<<5) /* IRQR: Interrupt Request Rate */ \
                                         | CONFIGURATION_REG_RST_NOT /* RST: do not reset device */ \
                                         | CONFIGURATION_REG_IRQEN /* IRQEN: enable interrupts */ \
                                         | 1 /* DCE and RUNE */)
/* I2C device address, defined with the AD0 pin of the device: */
#define MPR08x1_I2C_ADDR   0x5D  /* 7bit I2C address of the MPR084 with AD0 pin high */

/* Internal method prototypes */
static void WriteRegister(byte address, byte data);
static byte ReadRegister(byte address);

/*
** ===================================================================
**     Method      :  ReadRegister (component MPR08x)
**
**     Description :
**         Reads a register value from the device
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte ReadRegister(byte address)
{
  byte data, err;

  err = CI2C1_SelectSlave(MPR08x1_I2C_ADDR); /* Set slave address */
  if (err == ERR_DISABLED) { /* hmm, this should not be necessary? */
    (void)CI2C1_Enable();
    err = CI2C1_SelectSlave(MPR08x1_I2C_ADDR);
  }
  err = CI2C1_SendChar(address); /* send address byte */
  err = CI2C1_RecvChar(&data); /* Receive bytes in master mode */
  /* Now Data field contains received values */
  return data;
}

/*
** ===================================================================
**     Method      :  WriteRegister (component MPR08x)
**
**     Description :

**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void WriteRegister(byte address, byte data)
{
  /* send data to slave */
  byte msg[2], err;
  word ret;

  err = CI2C1_SelectSlave(MPR08x1_I2C_ADDR); /* Set slave address */
  if (err == ERR_DISABLED) { /* hmm, this should not be necessary? */
    (void)CI2C1_Enable();
    err = CI2C1_SelectSlave(MPR08x1_I2C_ADDR);
  }
  /* Send bytes in master mode */
  msg[0] = address;
  msg[1] = data;
  (void)CI2C1_SendBlock(&msg, sizeof(msg), &ret);
}

/*
** ===================================================================
**     Method      :  MPR08x1_Init (component MPR08x)
**
**     Description :
**         Device initialization routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void MPR08x1_Init(void)
{
  WAIT1_Waitms(50); /* wait some time to ensure device is powered up */
  TOGGLE_ATTN(); /* Ensure device is awake */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_DCE_NOT); /* make a global device reset */
  TOGGLE_ATTN(); /* Ensure device is awake */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_RST_NOT|CONFIGURATION_REG_DCE_NOT); /* Put in Stop 1 Mode for initial Config */
  WriteRegister(PAD_CONFIGURATION_REGISTER,
      0x80 | /* sounder enable */
      0x10 | /* auto calibration enable */
      0x04 | /* FIFO touch button buffer enable */
      0x01  /* touch buttons enable */
     );
  /* configure with choosen Run Mode */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REGISTER_SETTINGS);
  Irq1_Enable(); /* enable IRQ events from device */
}

/*
** ===================================================================
**     Method      :  MPR08x1_SetSensitivity (component MPR08x)
**     Description :
**         Specifies the sensor sensitivity level at runtime. Do NOT
**         call this function inside ProcessTouch().
**     Parameters  :
**         NAME            - DESCRIPTION
**         sensitivity     - sensitivity level, in the
**                           range of 1 to 64
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MPR08x1_SetSensitivity(byte sensitivity)
{
  if (sensitivity == 0 || sensitivity > 64) { /* value shall be in the range 1..64 */
    return ERR_RANGE;
  }
  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
  /* Set Sensitivity Threshold */
  WriteRegister(SENSITIVITY_1_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 1 */
  WriteRegister(SENSITIVITY_2_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 2 */
  WriteRegister(SENSITIVITY_3_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 3 */
  WriteRegister(SENSITIVITY_4_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 4 */
  WriteRegister(SENSITIVITY_5_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 5 */
  WriteRegister(SENSITIVITY_6_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 6 */
  WriteRegister(SENSITIVITY_7_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 7 */
  WriteRegister(SENSITIVITY_8_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 8 */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MPR08x1_SetSounder (component MPR08x)
**     Description :
**         Configures the sounder/buzzer at runtime. Do NOT call this
**         function inside ProcessTouch().
**     Parameters  :
**         NAME            - DESCRIPTION
**         enable          - If sounder shall be enabled or not.
**         clickPeriod     - The click period controls
**                           the length of the sounder click. 0 gives a
**                           10 ms period, and 1 gives a 20 ms click
**                           period.
**         frequency       - Controls the frequency of the
**                           driven output. A value of 0 gives 1 kHz,
**                           and 1 gives 2 kHz
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MPR08x1_SetSounder(bool enable, byte clickPeriod, byte frequency)
{

  if (enable && (clickPeriod > 1 || frequency > 1)) { /* clickperiod and frequency can be 0 or 1 */
    return ERR_RANGE;
  }
  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
  /* Enter Stop 1 Mode in order to write registers */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_RST_NOT|CONFIGURATION_REG_DCE_NOT);
  if (enable) {
    WriteRegister(SOUNDER_CONFIGURATION_REGISTER, (byte)((clickPeriod<<2)/*CP*/ | (frequency<<1)/*FREQ*/ | 0x01/*SEN*/));
  } else {
    WriteRegister(SOUNDER_CONFIGURATION_REGISTER, 0x00); /* disable sounder */
  }
  /* put device back to previous Run Mode */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REGISTER_SETTINGS);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MPR08x1_GetSensorInformation (component MPR08x)
**     Description :
**         Reads the sensor information from the device. If the buffer
**         is not large enough to get all the information, then the
**         next call to this function will return the remaining
**         information. In any case the buffer passed will be zero
**         terminated.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - pointer to a buffer for the information.
**         bufSize         - size of the buffer, including zero
**                           byte. A buffer size of at least 45 bytes
**                           should be passed.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MPR08x1_GetSensorInformation(byte *buf, byte bufSize)
{
  byte ch;

  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
  while (bufSize > 1) {
    ch = ReadRegister(SENSOR_INFORMATION_REGISTER);
    if (ch =='\0') { /* last byte received */
      break;
    }
    *buf = ch; buf++;
    bufSize--;
  }
  *buf = '\0';
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MPR08x1_ProcessTouch (component MPR08x)
**     Description :
**         Reads the sensor data and dispatches it to the corresponding
**         events. If the interrupts are enabled, this method is called
**         automatically in the interrupt service routine. Otherwise
**         you have to call this function from your application in
**         order to read the sensor (instantaneous mode).
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void MPR08x1_ProcessTouch(void)
{
  byte faultReg, pad;
  byte fifoReg;

  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
  /* Enter Stop1 Mode in order not to receive more interrupts */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_RST_NOT|CONFIGURATION_REG_DCE_NOT|CONFIGURATION_REG_RUNE);
  faultReg = (byte)(ReadRegister(FAULT_REGISTER)&0x7); /* Read Fault Register */
  if (faultReg != 0) { /* There was a fault! */
    WriteRegister(FAULT_REGISTER, 0); /* write to the fault register in stop mode will clear it */
  }
  /* use FIFO to get data */
  for(;;) {
    fifoReg = ReadRegister(FIFO_REGISTER);
    if (fifoReg&0x20 /* OF */) { /* Overflow Flag */
      /* The Overflow Flag shows whether or not an overflow has occurred. If this flag is high then the most current data was lost. */
      break;
    }
    if (fifoReg&0x40) {  /* NDF: No data flag: there is currently no data in the buffer. */
      break;
    }
    pad = (byte)(fifoReg&0x1F);
    if(pad&0x10) { /* TRF: Touch Release Flag: 1 if pad is touched */
      MPR08x1_OnPress((byte)(pad&0x0F)); /* e.g. 0 for button 3, etc */
    }
  } /* for */
  /* If having FIFO enabled or using interrupt mode: need to clear FIFO. In case of interrupts mode because of spurious interrupts which can happen during initalization. */
  WriteRegister(FIFO_REGISTER, 0); /* writing to the FIFO register clears it */
  (void)ReadRegister(FIFO_REGISTER); /* need to read back at least the NO DATA flag from FIFO, otherwise we are stuck! */
  /* Put the device back previous mode */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REGISTER_SETTINGS);
}

/*
** ===================================================================
**     Method      :  MPR08x1_OnInterrupt (component MPR08x)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void Irq1_OnInterrupt(void)
{
  MPR08x1_ProcessTouch();
}

/* END MPR08x1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale ColdFireV1 series of microcontrollers.
**
** ###################################################################
*/
